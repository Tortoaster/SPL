//prant(list) :: Show a => [a] -> Void {
//    print('[');
//    while(!isEmpty(list)) {
//        print(list.hd);
//        list = list.tl;
//        if(!isEmpty(list)) {
//            print(',');
//            print(' ');
//        }
//    }
//    print(']');
//}
//
//pront(tuple) :: Show a, Show b => (a, b) -> Void {
//    print('(');
//    print(tuple.fst);
//    print(',');
//    print(' ');
//    print(tuple.snd);
//    print(')');
//}
//
//eqq(l1, l2) :: Eq a => [a] [a] -> Bool {
//    while(!isEmpty(l1) && !isEmpty(l2)) {
//        if(l1.hd != l2.hd) {
//            return False;
//        }
//        l1 = l1.tl;
//        l2 = l2.tl;
//    }
//    return isEmpty(l1) && isEmpty(l2);
//}
//
//eqqq(t1, t2) :: Eq a, Eq b => (a, b) (a, b) -> Bool {
//    return t1.fst == t2.fst && t1.snd == t2.snd;
//}
var tuple = (0, 1);
var list = 3 : 7 : 11 : [];
var both = (tuple, list);
var ten = (1, 0);

var value1 = 4 + value2;
var value2 = 4;

isPrime(n) {
    var i = 2;
    if(n == 2) {
        return True;
    }
    if(n < 2) {
        return False;
    }
    while(i < n) {
        if(n % i == 0) {
            return False;
        }
        i = i + 1;
    }
    return True;
}

polySix(x) {
    return 6;
}

monomorphic(x, y) {
    return x == y;
}

// Should print 0123456789(1, 0)
main() {
    var i = 0;
    print(tuple.fst); // 0
    print(tuple.snd); // 1
    while(i < 2) {
        i = i + 1;
        tuple.fst = tuple.fst + tuple.snd;
    }
    print(tuple.fst); // 2
    print(list.hd); // 3
    list = list.tl;
    print(list.hd / 2 + 1); // 4
    list = list.tl;
    if(isPrime(list.hd)) {
        print(list.hd / 2); // 5
    } else {
        print(0);
    }
    print(polySix(True)); // 6
    if(monomorphic(3, 3)) {
        print(7); // 7
    }
    print(value1); // 8
    print(both.snd.hd + both.fst.snd * 6); // 9
    if(ten == (1, 0)) {
//        print(ten); // (1, 0)
    }
}
