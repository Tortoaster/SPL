\chapter{Analyses \& Typing}\label{chapter:typing}

\section{Polymorphic Type Inference}
Our SPL compiler features polymorphic type inference. We used Noah Weninger's implementation \cite{weninger_2016} as a reference, which is a Rust port of the algorithm described in Martin GrabmÃ¼ller's well-known paper on Algorithm W \cite{grabmuller}. For our implementation, we had to make quite a few adjustments, because SPL is an imperative language whereas the aforementioned resources both implemented the algorithm for the Lambda Calculus.

Our modified approach can be described as follows:
\begin{enumerate}
    \item We start by inspecting the top level declarations on duplicate declarations: all global variables must have a unique name, and all functions as well. A function and a variable are allowed to have the same name though, because these are namespaced in our environment.
    \item Then we generate the dependency graph. Every top-level variable and function has a dependency on other top-level variables and functions that are used in their declaration.
    \item We then perform Tarjan's algorithm on the dependency graph. This will give us the strongly connected components of the graph in reverse topological order. This is useful, because declarations within the same strongly connected component are all mutually recursive, and therefore their types need to be type inferenced at the same time, before any of them are generalized. The reverse topological sort ensures that we can type each of the declarations in order, without running into the problem that a dependency is not typed yet. Contrary to Haskell, Rust does not have a graph data structure in the standard library, and therefore no builtin way to find strongly connected components, or topologically sort them, so we used the PetGraph crate \cite{petgraph} for this.
    \item Then we perform a simple check to see if any variable declarations are in mutually recursive cycles. For example, if a variable @x@ is initialized with a function call to @f()@, which is defined as @f() { return x; }@, then @x@ obviously does not have a valid value, and therefore we throw an error. This check is a bit too conservative, as it rejects some programs that do not have this problem. If @f()@ were defined as follows:
    
    \begin{lstlisting}
    f() {
        if(True) {
            return 1;
        } else {
            return x;
        }
    }
    \end{lstlisting}
    
    then @x@ would have a correct value, but this program is rejected in order to prevent errors at runtime.
    \item Now we repeat the following steps for every strongly connected component generated by Tarjan's algorithm:
    \begin{enumerate}
        \item For every declaration in the strongly connected component, add its provisional type to the environment. For variables, this is either the type annotation they got, or a polymorphic type with a fresh type variable in case of @var@. For functions it works the same way: the type annotation is used if present, and otherwise a function with 2 arguments, for instance, will get a fresh type @a b -> c@.
        \item Now we type infer each of the declarations. This approach is straightforward, with the theory and the explanations in the next sections in mind.
        \item Finally, generalize all the types of the function declarations in this strongly connected component. This way, function calls to these functions will not change their types from then on. Variables do not get generalized.
    \end{enumerate}
\end{enumerate}

\section{Fields and Operators}
Notice how fields (@hd@, @tl@, @fst@, and @snd@, just the ones used in expressions, not on the left-hand side of assignments) and operators are all basically just functions:
\begin{lstlisting}[language=spl]
fst                       ::   (a, b) -> a
snd                       ::   (a, b) -> b
hd                        ::   [a] -> a
tl                        ::   [a] -> [a]
cons                      ::   a [a] -> [a]
add, sub, mul, div, mod   ::   Int Int -> Int
and, or                   ::   Bool Bool -> Bool
not                       ::   Bool -> Bool
\end{lstlisting}
Since these largely require the same code to infer their types, it saves a lot of duplicate code to have these translated to actual function calls by the parser. This way, an expression such as @x + 10@ is translated to @add(x, 10)@. We achieved this by adding the function signatures above to the starting environment of the typing algorithm. For now, that also means it is not allowed for the user to define their own function with the same identifier as any of these. We will explain how we plan to solve this, and what happened to the operators missing above, in the next section.

\section{Overloading}
To implement a form overloading in our compiler, we decided to mimic a construct from Haskell: type classes. Type classes impose restrictions on which types can be bound to type variables. For now, there are three present in our compiler: @Eq@, @Ord@, and @Show@, which complete our set of operators:
\begin{lstlisting}[language=spl]
eq, ne           ::   Eq a => a a -> Bool
lt, gt, le, ge   ::   Ord a => a a -> Bool
print            ::   Show a => a -> Void
\end{lstlisting}
Implementing these is straightforward as follows:
\begin{enumerate}
    \item Start by giving all type variables an empty set of type classes.
    \item When unifying two type variables, join their sets of type classes. For example, @a == b@ will impose the @Eq@ type class on both @a@ and @b@.
    \item When unifying type variables with other types, check whether that type implements all the type classes of the variable.
\end{enumerate}
For now, each of the type classes has the following types implement it:
\begin{lstlisting}[language=spl]
Eq     ->   Int, Bool, Char, (Eq, Eq), [Eq]
Ord    ->   Int, Char
Show   ->   Int, Bool, Char, (Show, Show), [Show]
\end{lstlisting}
Now, when we try to compile @a > True@, we get an error that says @Bool@ does not implement @Ord@, but comparing @Int@s and @Char@s will work just fine. As soon as code generation works properly, we plan to extend the language with custom type class instances. This allows the programmer to implement existing type classes on new types. For example, implementing @Ord a, Ord b => Ord for (a, b)@ would make @(1, 'a') < (2, 'b')@ a valid expression.

\section{Annotating Function Calls}
The code generation in the next stage requires that all overloaded function calls are annotated with the provided type arguments. For example, in the following function:
\begin{lstlisting}
f(a, b) :: Ord a => a a -> Bool {
    return a < b;
}
\end{lstlisting}
The function call @f(5, 7)@ would be annotated with @:: Int@, as @Int@ is the type provided for the type variable @a@, while @f('c', 'q')@ would be annotated with @:: Char@ instead. Notice that, because @<@ is translated to a function call, it should also be annotated with @:: a@, which will be updated to a concrete value when this function is generated. These annotations will be used for monomorphization later on, which enables us to generate specialized function variants for each type. We only have to do this for type variables that have type classes imposed on them, because only those will be passed to overloaded functions. Type variables without type classes are polymorphic; they work for any value, regardless of the type.

\section{Return Path Analysis}
For return path analysis, we make use of the fact that statements do not have a (useful) type themselves. When we infer the type of a statement, we return either an optional tuple of a type and a boolean, or an error. The type specifies the type of value that statement \textbf{returns}, whereas the boolean indicates whether or not the statement will always return something. Concretely, the following rules are used for typing statements:
\begin{lstlisting}
<var> = _;                             ::   Nothing
<fun>(_);                              ::   Nothing
return <exp>;                          ::   (ti(exp), True)
<stmts>                                ::   Unification of all return types
while(_) { <stmts> }                   ::   (ti(stmts).fst, False)
if(_) { <stmts1> } else { <stmts2> }   ::   Nothing if neither branch returns
    or, if both branches return something   (unification of both, True)
    or, if stmts1 returns something         (ti(stmts1).fst, False)
    or, if stmts2 returns something         (ti(stmts2).fst, False)
\end{lstlisting}

\section{Error Handling}
So far, the semantic analyses cover the following error types:

\begin{itemize}
    \item Types $t1$ and $t2$ do not unify
    \item Type $t$ does not implement type class $c$
    \item Unbound variable $v$
    \item Function $f$ is declared more than once
    \item Variable $v$ is declared more than once
    \item Occur check fails in type $t$
    \item Function $f$ does not return a value on all paths
    \item Cyclic reference in variable $v$
    \item Wrong number of arguments in function call $f$
\end{itemize}

Errors are not accumulated, but they do indicate the associated code in the original file. For example, the following code:

\begin{lstlisting}
f() {
    var x = 1;
    x = x + 1;
    if(x < 5) {
        return True;
    } else {
        return 1;
    }
    x = x + 2;
}
\end{lstlisting}

gives the following error:

\begin{lstlisting}[language={}]
Type error:
Type mismatch: expected Int, found Bool at 5:16:
|     if(x < 5) {
|         return True;
|                ^^^^
|     } else {
\end{lstlisting}

Type class errors, such as the one from the following code fragment:

\begin{lstlisting}
main(x, y) { return x > 'a' && y < True; }
\end{lstlisting}

looks as follows:

\begin{lstlisting}[language={}]
Type error:
Type Bool does not implement Ord at 1:36:
| main(x, y) { return x > 'a' && y < True; }
|                                    ^^^^
\end{lstlisting}

Finally, the following function does not have a valid return type on all paths:

\begin{lstlisting}
f() {
    var x = 1;
    x = x + 1;
    if(x < 5) {
        return True;
    }
    x = x + 2;
}
\end{lstlisting}

The resulting error looks as follows:

\begin{lstlisting}[language={}]
Type error:
Function f does not return a correct value in all paths at 3:5:
|     var x = 1;
|     x = x + 1;
|     ^^^^^^^^^^
|     if(x < 5) {
| ^^^^^^^^^^^^^^^
|         return True;
| ^^^^^^^^^^^^^^^^^^^^
|     }
| ^^^^^
|     x = x + 2;
| ^^^^^^^^^^^^^^
| }
\end{lstlisting}
